--IF COMMISSION_PCT IS NULL THEN SALARY 0 IF NOT NULL THEN INSERT EMPLOYEE SALARY

create or replace PROCEDURE COM_SAL IS
CURSOR C1 IS select employee_id,first_name,
case when commission_pct is not null then salary else 0 end salary,commission_pct  from employees;
X C1%ROWTYPE;
BEGIN
OPEN C1;
LOOP
FETCH C1 INTO X;
INSERT INTO COMSAL VALUES (X.EMPLOYEE_ID,X.FIRST_NAME,X.SALARY,X.COMMISSION_PCT);
EXIT WHEN C1%NOTFOUND;
END LOOP;
CLOSE C1;
END;

--FETCH FIRST_NAME WHEN GIVE A DEPARTMENT_ID IN IN PARAMETER

create or replace PROCEDURE EMPNAME (PIN IN NUMBER) IS
CURSOR C1 IS SELECT FIRST_NAME FROM EMPLOYEES WHERE DEPARTMENT_ID=PIN;
VNAME VARCHAR2(30);
BEGIN
OPEN C1;
LOOP
FETCH C1 INTO VNAME;
EXIT WHEN C1 %NOTFOUND;
DBMS_OUTPUT.PUT_LINE('EMPLOYEE_NAME= '||VNAME);
END LOOP;
CLOSE C1;
END;

-- WHEN GIVE A DAY IT GIVE HOW MANY DAYS IN A YEAR


create or replace PROCEDURE P_DATE 
(D  VARCHAR2) IS
X NUMBER:=0;
Y NUMBER:=0;
CURSOR C1 IS WITH NAN AS
(SELECT TRUNC(SYSDATE,'YYYY')+LEVEL-1 A,TO_CHAR(TRUNC(SYSDATE,'YYYY')+LEVEL-1,'DAY') B FROM DUAL
CONNECT BY LEVEL<=365)
SELECT A,B FROM NAN WHERE B=TO_CHAR(NEXT_DAY((TRUNC(SYSDATE,'YYYY')),D),'DAY');
V_V C1%ROWTYPE;
BEGIN
OPEN C1;
LOOP
FETCH C1 INTO V_V;
X:=C1%ROWCOUNT;
Y:=Y+X;
DBMS_OUTPUT.PUT_LINE(V_V.A||'   '||V_V.B||' '||'NO OF DAYS ='||X);
EXIT WHEN C1 %NOTFOUND;
END LOOP;
CLOSE C1;
END;

--FETCH RECORD

create or replace PROCEDURE P_REFCUR (P NUMBER,Q OUT SYS_REFCURSOR)
IS
BEGIN
OPEN Q FOR
WITH NAN AS
(SELECT E.*,ROW_NUMBER() OVER(ORDER BY EMPLOYEE_ID) RN FROM EMPLOYEES E)
, N1 AS (SELECT N.*,CASE    WHEN RN BETWEEN 1 AND 10 THEN 1
                            WHEN RN BETWEEN 11 AND 20 THEN 2
                            WHEN RN BETWEEN 21 AND 30 THEN 3
                            WHEN RN BETWEEN 31 AND 40 THEN 4
                            WHEN RN BETWEEN 41 AND 50 THEN 5
                            WHEN RN BETWEEN 51 AND 60 THEN 6
                            WHEN RN BETWEEN 61 AND 70 THEN 7
                            WHEN RN BETWEEN 71 AND 80 THEN 8
                            WHEN RN BETWEEN 81 AND 90 THEN 9
                            WHEN RN BETWEEN 91 AND 100 THEN 10
                            ELSE 11
                            END A  FROM NAN N) 
SELECT * FROM N1 WHERE A=P;
END ;


-----IN ND OUT PAARAMEETER

create or replace PROCEDURE PINOUT(P IN NUMBER,Q OUT NUMBER,R OUT VARCHAR2,S OUT VARCHAR2,T OUT VARCHAR2)
IS
X1 NUMBER;
X2 VARCHAR2(50);
X3 VARCHAR2(50);
X4 VARCHAR2(50);
BEGIN
SELECT E.EMPLOYEE_ID,D.DEPARTMENT_NAME,L.CITY,L.STREET_ADDRESS INTO X1,X2,X3,X4 FROM EMPLOYEES E JOIN DEPARTMENTS D 
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID JOIN LOCATIONS L
ON D.LOCATION_ID=L.LOCATION_ID WHERE D.DEPARTMENT_ID=P;
Q:=X1;
R:=X2;
S:=X3;
T:=X4;
END;

------IN OUT USING CURSOR


create or replace PROCEDURE PINOUTCUR(P IN NUMBER,Q OUT NUMBER,R OUT VARCHAR2,S OUT VARCHAR2,T OUT VARCHAR2)
IS
cursor c1 is SELECT E.EMPLOYEE_ID,D.DEPARTMENT_NAME,L.CITY,L.STREET_ADDRESS FROM EMPLOYEES E JOIN DEPARTMENTS D 
ON E.DEPARTMENT_ID=D.DEPARTMENT_ID JOIN LOCATIONS L
ON D.LOCATION_ID=L.LOCATION_ID WHERE D.DEPARTMENT_ID=P;
X1 NUMBER;
X2 VARCHAR2(50);
X3 VARCHAR2(50);
X4 VARCHAR2(50);
begin
open c1;
loop
fetch c1 into x1,x2,x3,x4;
exit when c1 %notfound;
end loop;
close c1;
Q:=X1;
R:=X2;
S:=X3;
T:=X4;
END;


-------------BULK COLLECT


create or replace PROCEDURE PROCAR1(PID IN ARRAY1) IS
X ARRAY1;
BEGIN
SELECT COL1(E.EMPLOYEE_ID,L.STREET_ADDRESS) BULK COLLECT INTO X FROM 
EMPLOYEES E JOIN DEPARTMENTS D ON E.DEPARTMENT_ID=D.DEPARTMENT_ID
JOIN LOCATIONS L ON L.LOCATION_ID=D.LOCATION_ID 
JOIN TABLE(PID) P ON E.EMPLOYEE_ID=P.ID;
FOR I IN 1..X.COUNT
LOOP
DBMS_OUTPUT.PUT_LINE(X(I).ID ||'     '|| X(I).STREET);
END LOOP;
END;



------SAVE EXCEPTION



create or replace PROCEDURE SAVE_EXCP1 IS

CURSOR CS1 IS SELECT * FROM savexcept1;

TYPE TY_EXCP IS TABLE OF CS1%ROWTYPE;

X TY_EXCP;
--ERR_MSG NUMBER;
IDX NUMBER;
BEGIN
OPEN CS1;
LOOP
FETCH CS1 BULK COLLECT INTO X;
FORALL I IN 1..X.COUNT SAVE EXCEPTIONS
INSERT INTO savexcept2 VALUES (X(I).ID);
EXIT WHEN CS1%NOTFOUND;
END LOOP;
CLOSE CS1;
ROLLBACK;
EXCEPTION
WHEN OTHERS THEN
--ERR_MSG:= SQL%BULK_EXCEPTIONS.COUNT;
FOR I IN 1..SQL%BULK_EXCEPTIONS.COUNT
LOOP
IDX:=SQL%BULK_EXCEPTIONS(I).ERROR_INDEX;
INSERT INTO savexcept3 values(X(IDX).ID);
DBMS_OUTPUT.PUT_LINE('ERROR'|| SQL%BULK_EXCEPTIONS(I).ERROR_INDEX||'     '||X(SQL%BULK_EXCEPTIONS(I).ERROR_INDEX).ID);
END LOOP;
END;




